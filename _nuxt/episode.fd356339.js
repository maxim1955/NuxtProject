import{r as v,i as E,j as O,k as x,l as b,m as T,h as D,n as B,q as A,s as S,c as p,g as C,F as P,o as h,a as M,t as m,b as G,w as H,e as N,d as j}from"./entry.59c8d7e1.js";import{C as z}from"./myStore.ae45275e.js";const F=()=>null;function I(...i){const c=typeof i[i.length-1]=="string"?i.pop():void 0;typeof i[0]!="string"&&i.unshift(c);let[a,o,s={}]=i;if(typeof a!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof o!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");s.server=s.server??!0,s.default=s.default??F,s.lazy=s.lazy??!1,s.immediate=s.immediate??!0;const e=T(),d=()=>e.isHydrating?e.payload.data[a]:e.static.data[a],y=()=>d()!==void 0;e._asyncData[a]||(e._asyncData[a]={data:v(d()??s.default()),pending:v(!y()),error:E(e.payload._errors,a),status:v("idle")});const t={...e._asyncData[a]};t.refresh=t.execute=(r={})=>{if(e._asyncDataPromises[a]){if(r.dedupe===!1)return e._asyncDataPromises[a];e._asyncDataPromises[a].cancelled=!0}if((r._initial||e.isHydrating&&r._initial!==!1)&&y())return d();t.pending.value=!0,t.status.value="pending";const f=new Promise((n,u)=>{try{n(o(e))}catch(w){u(w)}}).then(n=>{if(f.cancelled)return e._asyncDataPromises[a];let u=n;s.transform&&(u=s.transform(n)),s.pick&&(u=L(u,s.pick)),t.data.value=u,t.error.value=null,t.status.value="success"}).catch(n=>{if(f.cancelled)return e._asyncDataPromises[a];t.error.value=n,t.data.value=D(s.default()),t.status.value="error"}).finally(()=>{f.cancelled||(t.pending.value=!1,e.payload.data[a]=t.data.value,t.error.value&&(e.payload._errors[a]=B(t.error.value)),delete e._asyncDataPromises[a])});return e._asyncDataPromises[a]=f,e._asyncDataPromises[a]};const l=()=>t.refresh({_initial:!0}),_=s.server!==!1&&e.payload.serverRendered;{const r=A();if(r&&!r._nuxtOnBeforeMountCbs){r._nuxtOnBeforeMountCbs=[];const n=r._nuxtOnBeforeMountCbs;r&&(O(()=>{n.forEach(u=>{u()}),n.splice(0,n.length)}),x(()=>n.splice(0,n.length)))}_&&e.isHydrating&&y()?(t.pending.value=!1,t.status.value=t.error.value?"error":"success"):r&&(e.payload.serverRendered&&e.isHydrating||s.lazy)&&s.immediate?r._nuxtOnBeforeMountCbs.push(l):s.immediate&&l(),s.watch&&b(s.watch,()=>t.refresh());const f=e.hook("app:data:refresh",n=>{if(!n||n.includes(a))return t.refresh()});r&&x(f)}const g=Promise.resolve(e._asyncDataPromises[a]).then(()=>t);return Object.assign(g,t),g}function L(i,c){const a={};for(const o of c)a[o]=i[o];return a}const k="",$={__name:"episode",async setup(i){let c,a;const o=z();o.GET_EPISODE(),o.GET_CATALOG();const s=o.SET_EPISODES;o.SET_CATALOG;const{data:e}=([c,a]=S(()=>I("videos",()=>$fetch(k))),c=await c,a(),c);return(d,y)=>{const t=N;return h(!0),p(P,null,C(D(s),l=>(h(),p("div",{class:"card_person",key:l.id},[M("h2",null,"Карточка эпизода "+m(l.name),1),G(t,{onClick:_=>d.getPerson(l),to:"/character",class:"card_text"},{default:H(()=>[j(" Имя: "+m(l.name),1)]),_:2},1032,["onClick"]),(h(!0),p(P,null,C(l.characters,_=>(h(),p("div",null,m(k=_)+" "+m(D(e)),1))),256))]))),128)}}};export{$ as default};
